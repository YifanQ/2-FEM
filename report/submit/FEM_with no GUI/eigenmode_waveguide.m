close all; clear all; clc;

TE_or_TM='TM';
plotGeometry=false;
plotMatrix=false;

%% specify the model here!!! ===================================================
model_str = 'Circular_Model/';
% model_str = 'Rect_Model/';
load([model_str 'mesh.mat']);


%% process the p t e file generated by pdetool
% https://www.mathworks.com/help/pde/ug/pde.pdemodel.generatemesh.html
% https://www.mathworks.com/help/pde/ug/mesh-data.html
% e(6,k) is the subdomain number on the left side of the edge (subdomain 0 is the exterior of the geometry), where direction along the edge is given by increasing parameter values.
% e(7,k) is the subdomain number on the right side of the edge.
t = t(1:3,:);
b_e = e(1:2,:); % boundary edges, row 1 and 2: from which point to which point

tNum = size(t,2); fprintf('%s : # of triangles = %d\n\n', model_str(1:end-1), tNum);
b_eNum = size(b_e,2);
pNum = size(p,2);

all_n = [1:pNum].';
edge_n = unique(b_e(:));
int_n = setdiff(all_n, edge_n);

all_nNum = pNum;
int_nNum = size(int_n,1);

% logical array indicating a node in the internal or on the edge
int_or_edge = ones(pNum, 1);
int_or_edge(edge_n) = 0;
int_or_edge = logical(int_or_edge);

%% init A and B and FEM assembly
A = sparse(pNum, pNum);
B = sparse(pNum, pNum);

for ii = 1:tNum
    node = t(1:3, ii);
    [AA, BB] = get_AB(p(:,node));
    A(node, node) = A(node, node) + AA;
    B(node, node) = B(node, node) + BB;
end

fprintf(' A               dimension %d^2, # of non-zero elements in = %d\n',all_nNum, nnz(A));
fprintf(' A(int_n, int_n) dimension %d^2, # of non-zero elements in = %d\n',int_nNum, nnz(A(int_n, int_n)));

if plotMatrix
    figure(1);
    subplot(1,2,1);imagesc(full(A)~=0);
    title(sprintf('A (%d, %d)',all_nNum,all_nNum));colorbar;axis('image');
    subplot(1,2,2);imagesc(full(A(int_n, int_n))~=0);
    title(sprintf('A for internal nodes (%d, %d)',int_nNum,int_nNum));colorbar;axis('image');
end

%% prepare for eigs()
opts.issym = 1;
% opts.isreal = 1;
fprintf('\n\n ========================================== \n\nMATLAB version = %s\n\n', version);

% 9.2 R2017a; 9.3 R2017b
if verLessThan('matlab','9.3')
    sigma='sm';
else
    sigma='smallestabs';
end

%% get eigenvalue and eigenmode
if strcmp(TE_or_TM,'TM')
    % eig() not for sparse matrix 

    % d = eigs(A,B,___) solves the generalized eigenvalue problem A*V = B*V*D.
    % You can optionally specify k, sigma, opts, or name-value pairs as
    % additional input arguments.
    [V,D,flag] = eigs(A(int_n, int_n), B(int_n, int_n), 20, sigma, opts); 
    fprintf('--- eigs() convergence flag = %d\n', flag);
    % R2017a and earlier
    % sigma = 'sm' smallest magnitude
    % https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html
    
    % R2017b + 
    % sigma = 'smallestabs'
    % https://www.mathworks.com/help/matlab/ref/eigs.html look for sigma
    kt2 = diag(D);
    if ~issorted(kt2)
        [kt2,idx] = sort(kt2);
        V = V(:, idx);
    end
    kt = sqrt(kt2);

    figure(2);
    for eigen_ii=1:6
        subplot(2,3,eigen_ii);
        
        Ez_all = zeros(pNum, 1);
        Ez_all(int_n) = V(:,eigen_ii);
        trisurf(t.',p(1,:).',p(2,:).',Ez_all); shading interp; 
        view(2);xlabel('x'); ylabel('y'); zlabel('E_z');axis('equal');
        title(sprintf('k_c=%0.4f',kt(eigen_ii)));
        colorbar('Location','westoutside');
    end
    suptitle('E_z - first 6 TM modes');

    kt_exact_mn = load([model_str 'TMmodes.txt'],'-ascii'); kt_exact_mn = kt_exact_mn(1:20,:);
    kt_exact = kt_exact_mn(:,1);
    mn = kt_exact_mn(:,2:3);
    table = [kt, kt_exact, mn, kt./kt_exact];
    fprintf('\n\n ========================================== \n\n');
    fprintf('sim.   - theory m n - sim. / thoery\n');
    fprintf('%0.4f - %0.4f %d %d - %0.4f\n', table.');

end

if strcmp(TE_or_TM,'TE') % with Carl Neumann boundary condition
    % see comments for TM mode
    [V,D,flag] = eigs(A, B, 20+1, sigma, opts); 
    fprintf('--- eigs() convergence flag = %d\n', flag);
    
    kt2 = diag(D);
    if ~issorted(kt2)
        [kt2,idx] = sort(kt2);
        V = V(:, idx);
    end
    kt = sqrt(kt2);

    % drop kt = 0 mode
    fprintf('--- is first eigenvalue %0.4f == 0 ? %d\n', kt(1), abs(kt(1))<0.0001);
    kt2 = kt2(2:end);
    kt = kt(2:end);
    V = V(:, 2:end);
    

    figure(2);
    for eigen_ii=1:6
        subplot(2,3,eigen_ii);
        
        Hz_all = V(:,eigen_ii);
        trisurf(t.',p(1,:).',p(2,:).',Hz_all); shading interp; 
        view(2);xlabel('x'); ylabel('y'); zlabel('H_z');axis('equal');
        title(sprintf('k_c=%0.4f',kt(eigen_ii)));
        colorbar('Location','westoutside');
    end
    suptitle('H_z - first 6 TE modes');

    kt_exact_mn = load([model_str 'TEmodes.txt'],'-ascii'); kt_exact_mn = kt_exact_mn(1:20,:);
    kt_exact = kt_exact_mn(:,1);
    mn = kt_exact_mn(:,2:3);
    table = [kt, kt_exact, mn, kt./kt_exact];
    fprintf('\n\n ========================================== \n\n');
    fprintf('sim.   - theory m n - sim. / thoery\n');
    fprintf('%0.4f - %0.4f %d %d - %0.4f\n', table.');
end


if plotGeometry
figure(3);
subplot(1,3,1);
triplot(t.',p(1,:).',p(2,:).'); % TRI m x 3, x, y
xlabel('x'); ylabel('y'); axis('equal');

subplot(1,3,2);
x1_b_e = p(1,b_e(1,:));
x2_b_e = p(1,b_e(2,:));
y1_b_e = p(2,b_e(1,:));
y2_b_e = p(2,b_e(2,:));
x_b_e = [x1_b_e;x2_b_e;nan(1,b_eNum)];
y_b_e = [y1_b_e;y2_b_e;nan(1,b_eNum)];
plot(x_b_e(:), y_b_e(:), 'k.-');
xlabel('x'); ylabel('y'); axis('equal');
clear('x1_b_e','x2_b_e','y1_b_e','y2_b_e','x_b_e','y_b_e');
end